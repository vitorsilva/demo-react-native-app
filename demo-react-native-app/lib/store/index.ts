import { create } from 'zustand';
import { generateCombinations, GenerateCombinationsOptions } from '@/lib/business-logic/combinationGenerator';
import { getDatabase } from '@/lib/database';
import * as categoriesDb from '@/lib/database/categories';
import * as ingredientsDb from '@/lib/database/ingredients';
import * as mealLogsDb from '@/lib/database/mealLogs';
import * as mealTypesDb from '@/lib/database/mealTypes';
import * as preferencesDb from '@/lib/database/preferences';
import * as preparationMethodsDb from '@/lib/database/preparationMethods';
import * as mealComponentsDb from '@/lib/database/mealComponents';
import { setPreferences, UserPreferences } from '@/lib/database/preferences';
import { logger } from '@/lib/telemetry/logger';
import { getRecentlyUsedIngredients } from '../business-logic/varietyEngine';
import type { Ingredient, MealLog, Category, MealType, PreparationMethod, MealComponent } from '@/types/database';

// Create store logger instance
const storeLogger = logger.child({ module: 'Store' });

// Silent logging during tests
const isTestEnv = process.env.NODE_ENV === 'test';
const log = (message: string, data?: unknown) => {
  if (!isTestEnv) storeLogger.debug(message, data as Record<string, unknown>);
};

/**
 * Global application state managed by Zustand.
 * Contains all data entities and actions for the SaborSpin app.
 */
interface StoreState {
  // ─── State ─────────────────────────────────────────────────────────────────
  /** All ingredients in the database */
  ingredients: Ingredient[];
  /** Recent meal logs for history display */
  mealLogs: MealLog[];
  /** All ingredient categories */
  categories: Category[];
  /** All meal types (e.g., Breakfast, Lunch, Dinner) */
  mealTypes: MealType[];
  /** All preparation methods (predefined and custom) */
  preparationMethods: PreparationMethod[];
  /** Current meal suggestions generated by the algorithm */
  suggestedCombinations: Ingredient[][];
  /** True when any async operation is in progress */
  isLoading: boolean;
  /** Error message from the last failed operation */
  error: string | null;
  /** True after database initialization completes */
  isDatabaseReady: boolean;
  /** User preferences (cooldown days, suggestions count) */
  preferences: preferencesDb.UserPreferences;

  // ─── Ingredient Actions ────────────────────────────────────────────────────
  /** Loads all ingredients from the database into state */
  loadIngredients: () => Promise<void>;
  /** Creates a new ingredient in the database and adds it to state */
  addIngredient: (ingredient: {
    name: string;
    category: string;
    mealTypes: string[];
    category_id?: string;
    is_active?: boolean;
  }) => Promise<void>;
  /** Updates an existing ingredient's properties */
  updateIngredient: (id: string, updates: Partial<Pick<Ingredient, 'name' | 'category' | 'mealTypes' | 'category_id' | 'is_active'>>) => Promise<void>;
  /** Toggles an ingredient's active status (may fail if it's the last active) */
  toggleIngredientActive: (id: string) => Promise<void>;
  /** Deletes an ingredient (may fail if it's the last active for a meal type) */
  deleteIngredient: (id: string) => Promise<void>;

  // ─── Category Actions ──────────────────────────────────────────────────────
  /** Loads all categories from the database into state */
  loadCategories: () => Promise<void>;
  /** Creates a new category */
  addCategory: (name: string) => Promise<void>;
  /** Updates a category's name */
  updateCategory: (id: string, name: string) => Promise<void>;
  /** Deletes a category (fails if ingredients are assigned to it) */
  deleteCategory: (id: string) => Promise<{ success: boolean; error?: string }>;

  // ─── Meal Type Actions ─────────────────────────────────────────────────────
  /** Loads all meal types from the database into state */
  loadMealTypes: () => Promise<void>;
  /** Creates a new meal type with optional configuration */
  addMealType: (params: {
    name: string;
    min_ingredients?: number;
    max_ingredients?: number;
    default_cooldown_days?: number;
    is_active?: boolean;
  }) => Promise<void>;
  /** Updates a meal type's properties */
  updateMealType: (id: string, updates: Partial<Pick<MealType, 'name' | 'min_ingredients' | 'max_ingredients' | 'default_cooldown_days' | 'is_active'>>) => Promise<void>;
  /** Deletes a meal type (fails if meal logs or ingredients reference it) */
  deleteMealType: (id: string) => Promise<{ success: boolean; error?: string }>;

  // ─── Preparation Method Actions ─────────────────────────────────────────────
  /** Loads all preparation methods from the database into state */
  loadPreparationMethods: () => Promise<void>;
  /** Adds a custom preparation method */
  addPreparationMethod: (name: string) => Promise<PreparationMethod>;
  /** Deletes a custom preparation method (predefined methods cannot be deleted) */
  deletePreparationMethod: (id: string) => Promise<{ success: boolean; error?: string }>;

  // ─── Meal Log Actions ──────────────────────────────────────────────────────
  /** Loads recent meal logs from the database */
  loadMealLogs: (days?: number) => Promise<void>;
  /** Records a new meal log entry */
  logMeal: (mealLog: Omit<MealLog, 'id' | 'createdAt' | 'isFavorite'> & { isFavorite?: boolean }) => Promise<void>;
  /** Toggles the favorite status of a meal log */
  toggleMealLogFavorite: (id: string) => Promise<void>;
  /**
   * Logs a meal with components (ingredient + preparation method pairs).
   * This is the Phase 2 way to log meals with preparation methods and optional names.
   */
  logMealWithComponents: (
    mealTypeId: string,
    components: { ingredientId: string; preparationMethodId: string | null }[],
    name?: string
  ) => Promise<MealLog & { components: MealComponent[] }>;
  /**
   * Retrieves a meal log with its components attached.
   */
  getMealWithComponents: (mealLogId: string) => Promise<(MealLog & { components: MealComponent[] }) | null>;

  // ─── Other Actions ─────────────────────────────────────────────────────────
  /** Loads user preferences from the database */
  loadPreferences: () => Promise<void>;
  /** Updates user preferences in the database and state */
  updatePreferences: (preferences: preferencesDb.UserPreferences) => Promise<void>;
  /** Marks the database as initialized and ready */
  setDatabaseReady: () => void;
  /**
   * Generates meal suggestions using the variety engine.
   * Applies cooldown filtering and respects meal type configuration.
   * @param mealTypeName - Optional meal type to use for min/max ingredients config
   */
  generateMealSuggestions: (mealTypeName?: string) => Promise<void>;
}

export const useStore = create<StoreState>((set, get) => ({
  // Initial state values
  ingredients: [],
  mealLogs: [],
  categories: [],
  mealTypes: [],
  preparationMethods: [],
  suggestedCombinations: [],
  isLoading: false,
  error: null,
  isDatabaseReady: false,
  preferences: {
    cooldownDays: 3,
    suggestionsCount: 4,
    hapticEnabled: true,
  },

  // Load preferences from database
  loadPreferences: async () => {
    try {
      const db = getDatabase();
      const prefs = await preferencesDb.getPreferences(db);
      set({ preferences: prefs });
    } catch (error) {
      console.error('Failed to load preferences:', error);
    }
  },

  // Update preferences in database and state
  updatePreferences: async (newPreferences: UserPreferences) => {
    try {
      const db = getDatabase();
      await setPreferences(db, newPreferences);
      set({ preferences: newPreferences });
    } catch (error) {
      console.error('Failed to update preferences:', error);
      set({ error: 'Failed to update preferences' });
    }
  },

  // Action: Load all ingredients from database
  loadIngredients: async () => {
    set({ isLoading: true, error: null });
    try {
      const db = getDatabase();
      const ingredients = await ingredientsDb.getAllIngredients(db);
      set({ ingredients, isLoading: false });
    } catch (error) {
      set({
        error: error instanceof Error ? error.message : 'Failed to load ingredients',
        isLoading: false,
      });
    }
  },

  // Action: Load meal logs from database
  loadMealLogs: async (days = 30) => {
    set({ isLoading: true, error: null });
    try {
      const db = getDatabase();
      const mealLogs = await mealLogsDb.getRecentMealLogs(db, days);
      set({ mealLogs, isLoading: false });
    } catch (error) {
      set({
        error: error instanceof Error ? error.message : 'Failed to load meal logs',
        isLoading: false,
      });
    }
  },

  // Action: Add a new ingredient
  addIngredient: async (ingredient) => {
    set({ isLoading: true, error: null });
    try {
      const db = getDatabase();
      const newIngredient = await ingredientsDb.addIngredient(db, ingredient);
      set((state) => ({
        ingredients: [...state.ingredients, newIngredient],
        isLoading: false,
      }));
    } catch (error) {
      set({
        error: error instanceof Error ? error.message : 'Failed to add ingredient',
        isLoading: false,
      });
    }
  },

  // Action: Log a meal (we'll enhance this with variety logic later)
  logMeal: async (mealLog) => {
    set({ isLoading: true, error: null });
    try {
      const db = getDatabase();
      const newLog = await mealLogsDb.logMeal(db, mealLog);
      set((state) => ({
        mealLogs: [...state.mealLogs, newLog],
        isLoading: false,
      }));
    } catch (error) {
      set({
        error: error instanceof Error ? error.message : 'Failed to log meal',
        isLoading: false,
      });
    }
  },

  // Action: Toggle meal log favorite status
  toggleMealLogFavorite: async (id) => {
    set({ isLoading: true, error: null });
    try {
      const db = getDatabase();
      const updatedLog = await mealLogsDb.toggleMealLogFavorite(db, id);
      set((state) => ({
        mealLogs: state.mealLogs.map((log) => (log.id === id ? updatedLog : log)),
        isLoading: false,
      }));
    } catch (error) {
      set({
        error: error instanceof Error ? error.message : 'Failed to toggle favorite',
        isLoading: false,
      });
    }
  },

  // Action: Generate variety-enforced meal suggestions
  // Can optionally take a meal type name to use its specific configuration
  generateMealSuggestions: async (mealTypeName?: string) => {
    const startTime = Date.now();

    // Track action start
    storeLogger.action('generate_suggestions_start', { mealTypeName });

    set({ isLoading: true, error: null });
    try {
      const db = getDatabase();

      // Step 1: Load fresh preferences from database
      const preferences = await preferencesDb.getPreferences(db);
      const count = preferences.suggestionsCount;

      // Step 2: Get meal type config if specified, otherwise use defaults
      let minIngredients = 1;
      let maxIngredients = 3;
      let cooldownDays = preferences.cooldownDays;

      if (mealTypeName) {
        const { mealTypes } = get();
        const mealType = mealTypes.find(
          (mt) => mt.name.toLowerCase() === mealTypeName.toLowerCase()
        );
        if (mealType) {
          minIngredients = mealType.min_ingredients;
          maxIngredients = mealType.max_ingredients;
          cooldownDays = mealType.default_cooldown_days;
          log('Using meal type config:', { mealTypeName, minIngredients, maxIngredients, cooldownDays });
        }
      }

      // Step 3: Get current ingredients from store
      const { ingredients } = get();

      // Step 4: Get recent meal logs from database
      const recentMealLogs = await mealLogsDb.getRecentMealLogs(db, cooldownDays);

      // Step 5: Extract blocked ingredient IDs
      const blockedIds = getRecentlyUsedIngredients(recentMealLogs);

      // Step 6: Generate combinations with variety enforcement and meal type config
      const options: GenerateCombinationsOptions = {
        minIngredients,
        maxIngredients,
        filterInactive: true, // Always filter out inactive ingredients
      };
      const combinations = generateCombinations(ingredients, count, blockedIds, options);

      const duration = Date.now() - startTime;

      // Record performance and success
      storeLogger.perf('meal_generation', {
        value: duration,
        status: 'success',
        suggestionsGenerated: combinations.length,
        mealTypeName,
      });

      set({ suggestedCombinations: combinations, isLoading: false });
      log('Generation complete:', { duration, suggestionsCount: combinations.length });
    } catch (error) {
      const duration = Date.now() - startTime;

      // Record failure
      storeLogger.perf('meal_generation', {
        value: duration,
        status: 'error',
        error: error instanceof Error ? error.message : 'Unknown error',
      });

      set({
        error: error instanceof Error ? error.message : 'Failed to generate suggestions',
        isLoading: false,
      });
    }
  },

  // Action: Update an ingredient
  updateIngredient: async (id, updates) => {
    set({ isLoading: true, error: null });
    try {
      const db = getDatabase();
      const updated = await ingredientsDb.updateIngredient(db, id, updates);
      if (updated) {
        set((state) => ({
          ingredients: state.ingredients.map((ing) => (ing.id === id ? updated : ing)),
          isLoading: false,
        }));
      } else {
        set({ isLoading: false, error: 'Ingredient not found' });
      }
    } catch (error) {
      set({
        error: error instanceof Error ? error.message : 'Failed to update ingredient',
        isLoading: false,
      });
    }
  },

  // Action: Toggle ingredient active status
  toggleIngredientActive: async (id) => {
    set({ isLoading: true, error: null });
    try {
      const db = getDatabase();
      const result = await ingredientsDb.toggleIngredientActive(db, id);
      if (result.ingredient) {
        set((state) => ({
          ingredients: state.ingredients.map((ing) => (ing.id === id ? result.ingredient! : ing)),
          isLoading: false,
        }));
      } else {
        set({ isLoading: false, error: result.error || 'Ingredient not found' });
      }
    } catch (error) {
      set({
        error: error instanceof Error ? error.message : 'Failed to toggle ingredient',
        isLoading: false,
      });
    }
  },

  // Action: Delete an ingredient
  deleteIngredient: async (id) => {
    set({ isLoading: true, error: null });
    try {
      const db = getDatabase();
      const result = await ingredientsDb.deleteIngredient(db, id);
      if (result.success) {
        set((state) => ({
          ingredients: state.ingredients.filter((ing) => ing.id !== id),
          isLoading: false,
        }));
      } else {
        set({ error: result.error, isLoading: false });
      }
    } catch (error) {
      set({
        error: error instanceof Error ? error.message : 'Failed to delete ingredient',
        isLoading: false,
      });
    }
  },

  // Action: Load all categories
  loadCategories: async () => {
    set({ isLoading: true, error: null });
    try {
      const db = getDatabase();
      const categories = await categoriesDb.getAllCategories(db);
      set({ categories, isLoading: false });
    } catch (error) {
      set({
        error: error instanceof Error ? error.message : 'Failed to load categories',
        isLoading: false,
      });
    }
  },

  // Action: Add a new category
  addCategory: async (name) => {
    set({ isLoading: true, error: null });
    try {
      const db = getDatabase();
      const newCategory = await categoriesDb.addCategory(db, { name });
      set((state) => ({
        categories: [...state.categories, newCategory],
        isLoading: false,
      }));
    } catch (error) {
      set({
        error: error instanceof Error ? error.message : 'Failed to add category',
        isLoading: false,
      });
    }
  },

  // Action: Update a category
  updateCategory: async (id, name) => {
    set({ isLoading: true, error: null });
    try {
      const db = getDatabase();
      const updated = await categoriesDb.updateCategory(db, id, { name });
      if (updated) {
        set((state) => ({
          categories: state.categories.map((cat) => (cat.id === id ? updated : cat)),
          isLoading: false,
        }));
      } else {
        set({ isLoading: false, error: 'Category not found' });
      }
    } catch (error) {
      set({
        error: error instanceof Error ? error.message : 'Failed to update category',
        isLoading: false,
      });
    }
  },

  // Action: Delete a category
  deleteCategory: async (id) => {
    set({ isLoading: true, error: null });
    try {
      const db = getDatabase();
      const result = await categoriesDb.deleteCategory(db, id);
      if (result.success) {
        set((state) => ({
          categories: state.categories.filter((cat) => cat.id !== id),
          isLoading: false,
        }));
      } else {
        set({ error: result.error, isLoading: false });
      }
      return result;
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Failed to delete category';
      set({ error: errorMsg, isLoading: false });
      return { success: false, error: errorMsg };
    }
  },

  // Action: Load all meal types
  loadMealTypes: async () => {
    set({ isLoading: true, error: null });
    try {
      const db = getDatabase();
      const mealTypes = await mealTypesDb.getAllMealTypes(db);
      set({ mealTypes, isLoading: false });
    } catch (error) {
      set({
        error: error instanceof Error ? error.message : 'Failed to load meal types',
        isLoading: false,
      });
    }
  },

  // Action: Add a new meal type
  addMealType: async (params) => {
    set({ isLoading: true, error: null });
    try {
      const db = getDatabase();
      const newMealType = await mealTypesDb.addMealType(db, params);
      set((state) => ({
        mealTypes: [...state.mealTypes, newMealType],
        isLoading: false,
      }));
    } catch (error) {
      set({
        error: error instanceof Error ? error.message : 'Failed to add meal type',
        isLoading: false,
      });
    }
  },

  // Action: Update a meal type
  updateMealType: async (id, updates) => {
    set({ isLoading: true, error: null });
    try {
      const db = getDatabase();
      const updated = await mealTypesDb.updateMealType(db, id, updates);
      if (updated) {
        set((state) => ({
          mealTypes: state.mealTypes.map((mt) => (mt.id === id ? updated : mt)),
          isLoading: false,
        }));
      } else {
        set({ isLoading: false, error: 'Meal type not found' });
      }
    } catch (error) {
      set({
        error: error instanceof Error ? error.message : 'Failed to update meal type',
        isLoading: false,
      });
    }
  },

  // Action: Delete a meal type
  deleteMealType: async (id) => {
    set({ isLoading: true, error: null });
    try {
      const db = getDatabase();
      const result = await mealTypesDb.deleteMealType(db, id);
      if (result.success) {
        set((state) => ({
          mealTypes: state.mealTypes.filter((mt) => mt.id !== id),
          isLoading: false,
        }));
      } else {
        set({ error: result.error, isLoading: false });
      }
      return result;
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Failed to delete meal type';
      set({ error: errorMsg, isLoading: false });
      return { success: false, error: errorMsg };
    }
  },

  // Action: Load all preparation methods
  loadPreparationMethods: async () => {
    set({ isLoading: true, error: null });
    try {
      const db = getDatabase();
      const preparationMethods = await preparationMethodsDb.getAllPreparationMethods(db);
      set({ preparationMethods, isLoading: false });
    } catch (error) {
      set({
        error: error instanceof Error ? error.message : 'Failed to load preparation methods',
        isLoading: false,
      });
    }
  },

  // Action: Add a custom preparation method
  addPreparationMethod: async (name) => {
    set({ isLoading: true, error: null });
    try {
      const db = getDatabase();
      const newMethod = await preparationMethodsDb.addPreparationMethod(db, name);
      set((state) => ({
        preparationMethods: [...state.preparationMethods, newMethod],
        isLoading: false,
      }));
      return newMethod;
    } catch (error) {
      set({
        error: error instanceof Error ? error.message : 'Failed to add preparation method',
        isLoading: false,
      });
      throw error;
    }
  },

  // Action: Delete a custom preparation method
  deletePreparationMethod: async (id) => {
    set({ isLoading: true, error: null });
    try {
      const db = getDatabase();
      const result = await preparationMethodsDb.deletePreparationMethod(db, id);
      if (result.success) {
        set((state) => ({
          preparationMethods: state.preparationMethods.filter((pm) => pm.id !== id),
          isLoading: false,
        }));
      } else {
        set({ error: result.error, isLoading: false });
      }
      return result;
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : 'Failed to delete preparation method';
      set({ error: errorMsg, isLoading: false });
      return { success: false, error: errorMsg };
    }
  },

  // Action: Log a meal with components (Phase 2)
  logMealWithComponents: async (mealTypeId, components, name) => {
    set({ isLoading: true, error: null });
    try {
      const db = getDatabase();
      const now = new Date().toISOString();
      const newLog = await mealComponentsDb.logMealWithComponents(
        db,
        { date: now, mealType: mealTypeId, isFavorite: false },
        components,
        name
      );
      set((state) => ({
        mealLogs: [...state.mealLogs, newLog],
        isLoading: false,
      }));
      return newLog;
    } catch (error) {
      set({
        error: error instanceof Error ? error.message : 'Failed to log meal with components',
        isLoading: false,
      });
      throw error;
    }
  },

  // Action: Get a meal with its components
  getMealWithComponents: async (mealLogId) => {
    set({ isLoading: true, error: null });
    try {
      const db = getDatabase();
      const mealWithComponents = await mealComponentsDb.getMealLogWithComponents(db, mealLogId);
      set({ isLoading: false });
      return mealWithComponents;
    } catch (error) {
      set({
        error: error instanceof Error ? error.message : 'Failed to get meal with components',
        isLoading: false,
      });
      throw error;
    }
  },

  // Action: Mark database as ready
  setDatabaseReady: () => set({ isDatabaseReady: true }),
}));
